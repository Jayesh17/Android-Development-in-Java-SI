package com.company;
import java.util.*;

class Student
{
    private int id;
    private String name;
    // this block always called before any constructor.
    {
        System.out.println("This is init block");
    }
    Student(){}
    Student(int id, String nm)
    {
        this.id = id;
        this.name = nm;
    }
    public void showRecord()
    {
        System.out.println(id+" "+name);
    }
    Student(Student s)
    {
        // to call default constructor - this()
        id = s.id;
        name = s.name;
    }
    public void changeValue(Student s)
    {
        s.id++;
        s.name= "Jayesh";
    }
};
//Implements singleton design concept.
class Database
{
  static Database db = null;
  String lang;
  private Database() {}
  static public Database addLanguage(String l)
  {
      if(db==null) {
          db = new Database();
          db.lang = l;
      }
      return db;
  }
  public void langConnected()
  {
      System.out.println("Database is connected with  "+ lang);
  }
};

class anms
{
   anms()
  {
      System.out.println("this is the anonumous function");
  }

};


abstract class Parent
{
    abstract public void msg1();
    public void msg2()
    {
        System.out.println("This is Msg2 from Parent class");
    }
//    If we don’t want a method to be overridden, we declare it as final.
    final public void msg3()
    {
        System.out.println("This is Msg3 from Parent class");
    }
}

class Child1 extends Parent
{
    public void msg1()
    {
        System.out.println("This is MSg1 from child1 class");
    }
};
class Child2 extends Parent
{
    public void msg1() // we can change the accessibility of instance while extending and overriding
    {
        System.out.println("This is MSg1 from child2 class");
    }
};

public class Main {

    public static void fn1(int n)
    {
        n++;
    }
    public static void main(String[] args) {
	// write your code here
        System.out.println("hello");

        //The Java codes are first compiled into byte code (machine independent code). Then the byte code runs on Java Virtual Machine (JVM) regardless of the underlying architecture.
        //Writing a program is done by a java programmer like you and me.
        //The compilation is done by the JAVAC compiler which is a primary Java compiler included in the Java development kit (JDK). It takes Java program as input and generates bytecode as output.
        //In the Running phase of a program, JVM executes the bytecode generated by the compiler

        //JVM is part of JRE and JRE is the part of JDK

        //Execution
        //Interpreter: It interprets the bytecode line by line and then executes. The disadvantage here is that when one method is called multiple times, every time interpretation is required.
        //Just-In-Time Compiler(JIT) : It is used to increase the efficiency of an interpreter. It compiles the entire bytecode and changes it to native code so whenever the interpreter sees repeated method calls, JIT provides direct native code for that part so re-interpretation is not required, thus efficiency is improved.

        //In Java, programmers can’t delete the objects. To delete or recollect that memory JVM has a program called Garbage Collector. Garbage Collectors can recollect the of objects that are not referenced. So Java makes the life of a programmer easy by handling memory management. However, programmers should be careful about their code whether they are using objects that have been used for a long time. Because Garbage cannot recover the memory of objects being referenced.

        //command line arg : alt+shift+f10 to change the program config, shift+f10 run
        for(String val : args)
        {
            System.out.println(val+" ");
        }

        //But java uses the Unicode system not the ASCII code system and to represent Unicode system 8 bit is not enough to represent all characters so java uses 2 bytes for characters.

        //Java strings are not terminated with a null character.

        //Since arrays are immutable(cannot grow), Strings are immutable as well. Whenever a change to a String is made, an entirely new String is created

        //Usefull functions of string:
        // indexOf(str), substring(in1,in2), concat(s1,s2), lastIndexOf(str), str1.equals(str2),
        // str1.equalsIgnoreCase(str2), .trim()- white spaces, .replace(what,str)
        // toLowerCase() or toUpperCase()

        //StringBuffer

        //userfull fun: length(), capacity(), append(str or int), insert(index,what), reverse(),
        // delete(in1,in2), deleteCharAt(index), charAt(ch), indexOf(str), setcharAt(ind,ch),

        String s1 = new String("Hello");
        s1 = s1 + "Bye";
        System.out.println(s1);

        //In Java, all arrays are dynamically allocated.

        int[] a = new int[10];
        int[] b = {1,2,4,5,6,7,1,9,0,3};
        for(int i = 0;i<a.length; i++)
        {
            a[i] = i;
            System.out.print(" "+a[i]);
        }
        System.out.println("\n");
        for(int ii: b)
        {
            System.out.print(" "+ii);
        }


        //Taking User inputs
        /*Scanner in = new Scanner(System.in);

        System.out.println("enter String");
        String s = in.nextLine();

        System.out.println("enter Int");
        int n = in.nextInt();

        System.out.println(n+" "+s);*/

        //Jagged array

        String arrs[][] = new String[][]
        {
                new String[]{"jayesh","Jitubhai", "Lalchandani"},
                new String[]{"joy", "Lalchandani"},
                new String[]{"Jayesh", "Lalchandani"}
        };

        String arrs2[][] = arrs; // Just reference initialization not copy.

        for(String name[]: arrs)
        {
            for (String fullname : name)
            {
                System.out.print(fullname+" ");
            }
            System.out.println();
        }

        //Copy one array to another
        String arrs3[][] = arrs.clone();
        // other : arrays.copyOf(array_name, how many), arrays.copyOfRange(array_name, st,end),

        //convert array to string
        int a1[][] = {{1,1,1},{1,1,1}};
        int a2[][] = {{1,1,1},{1,1,1}};
        String copystr = Arrays.toString(a1);
        System.out.println(copystr);
        //if array contains some objects elements or multidimenstionals, than it should be compare
        // with deepEquals()
        System.out.println(Arrays.deepEquals(a1,a2));

        //Java is strictly pass by value.
        //by value
        int t = 30;
        fn1(t);
        System.out.println(t);
        //Good practise is create one reference and point it to different memories, mostly used
        // in inheritance where we create parent class reference and creates child class memory.

        Student std = new Student(12013,"Joy");
        std.showRecord();

        // Like C++, Java does not provide default copy constructor.
        Student std1 = new Student(std);
        std.changeValue(std);
        std.showRecord();
        std1.showRecord();

        // anonomous objects are not referenced by any class reference, they are created for just
        // method calling
            new anms();

        /*What is a Singleton class?
        As the name implies, a class is said to be singleton if it limits the number of objects of that class to one.
        We can’t have more than a single object for such classes.*/

//        Implementation of the singleton design pattern
        Database db1 = Database.addLanguage("Java");
        Database db2 = Database.addLanguage("C++");// will not create any instance of Database
        // object , rather point to same db1

        db1.langConnected();
        db2.langConnected();

        // Java doesn’t support the Operator Overloading.
        //An abstract class is a class that is declared with abstract keyword.
        //An abstract method is a method that is declared without implementation.
        //An abstract class may or may not have all abstract methods. Some of them can be concrete methods
        //static methods cannot be overridden
        //Method overriding
        Parent p;
        p = new Child1();
        p.msg1();
        p.msg2();

        p = new Child2();
        p.msg1();
        p.msg2();

        //all the methods in an interface are declared with an empty body and are public and all fields are public, static and final by default.
    }
}
